const express = require('express');
const router = express.Router();
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const { auth } = require('../middlewares/auth');

// ƒêƒÉng k√Ω
router.post('/register', async (req, res) => {
  try {
    const { name, email, password, role, bankAccount, bankName, balance, referralCode } = req.body;
    const existingUser = await User.findOne({ email });
    if (existingUser) return res.status(400).json({ message: 'Email ƒë√£ t·ªìn t·∫°i' });
    
    let userRole = 'user';
    const userCount = await User.countDocuments();
    // N·∫øu l√† user ƒë·∫ßu ti√™n, t·ª± ƒë·ªông l√† admin
    if (userCount === 0) {
      userRole = 'admin';
    } else if (role === 'admin' && req.headers.authorization) {
      try {
        const token = req.headers.authorization.split(' ')[1];
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        if (decoded.role === 'admin') userRole = 'admin';
      } catch {}
    } else if (role === 'user') {
      userRole = 'user';
    }

    // X·ª≠ l√Ω m√£ gi·ªõi thi·ªáu (email)
    let referredBy = null;
    if (referralCode && referralCode.trim()) {
      // Ki·ªÉm tra email h·ª£p l·ªá
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(referralCode)) {
        return res.status(400).json({ message: 'Email ng∆∞·ªùi gi·ªõi thi·ªáu kh√¥ng h·ª£p l·ªá' });
      }
      
      // T√¨m user c√≥ email n√†y
      const referrer = await User.findOne({ email: referralCode.toLowerCase() });
      if (!referrer) {
        return res.status(400).json({ message: 'Email ng∆∞·ªùi gi·ªõi thi·ªáu kh√¥ng t·ªìn t·∫°i' });
      }
      
      referredBy = referrer._id;
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    
    // S·ª≠ d·ª•ng email l√†m m√£ gi·ªõi thi·ªáu
    const newReferralCode = email;
    
    const userData = { 
      name, 
      email, 
      password: hashedPassword, 
      role: userRole,
      bankAccount: bankAccount || '',
      bankName: bankName || '',
      balance: balance || 0,
      referralCode: newReferralCode,
      referredBy: referredBy
    };
    
    const user = new User(userData);
    await user.save();

    // √Åp d·ª•ng khuy·∫øn m√£i cho th√†nh vi√™n m·ªõi
    const promotionController = require('../controllers/promotionController');
    const promotionApplied = await promotionController.applyPromotionToNewUser(user._id);
    if (promotionApplied) {
      console.log(`üéÅ Promotion applied to new user: ${user.email}`);
    }

    // N·∫øu c√≥ ng∆∞·ªùi gi·ªõi thi·ªáu, c·∫≠p nh·∫≠t th·ªëng k√™ v√† t·∫°o th√¥ng b√°o
    if (referredBy) {
      await User.findByIdAndUpdate(referredBy, {
        $inc: { referralCount: 1 },
        $push: {
          referralHistory: {
            referredUser: user._id,
            amount: 0, // Ch∆∞a c√≥ th∆∞·ªüng v√¨ ch∆∞a n·∫°p ti·ªÅn
            type: 'new_referral',
            date: new Date()
          }
        }
      });
      
      // T·∫°o th√¥ng b√°o cho ng∆∞·ªùi gi·ªõi thi·ªáu
      const Notification = require('../models/Notification');
      const notification = new Notification({
        recipient: referredBy,
        title: 'Ng∆∞·ªùi ƒë∆∞·ª£c gi·ªõi thi·ªáu m·ªõi',
        message: `${user.name} ƒë√£ ƒëƒÉng k√Ω v·ªõi m√£ gi·ªõi thi·ªáu c·ªßa b·∫°n!`,
        type: 'referral',
        data: {
          referredUserId: user._id,
          referredUserName: user.name,
          referredUserEmail: user.email
        }
      });
      await notification.save();
      
      console.log(`Referral count updated and notification created for user ${referredBy}`);
    }

    res.status(201).json({ message: 'ƒêƒÉng k√Ω th√†nh c√¥ng', role: userRole });
  } catch (err) {
    console.error('Error in register:', err);
    res.status(500).json({ message: 'L·ªói server' });
  }
});

// Ki·ªÉm tra m√£ gi·ªõi thi·ªáu
router.post('/check-referral', async (req, res) => {
  try {
    const { referralCode } = req.body;
    
    if (!referralCode || !referralCode.trim()) {
      return res.status(400).json({ 
        valid: false, 
        message: 'Vui l√≤ng nh·∫≠p email ng∆∞·ªùi gi·ªõi thi·ªáu' 
      });
    }

    // Ki·ªÉm tra email h·ª£p l·ªá
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(referralCode)) {
      return res.status(400).json({ 
        valid: false, 
        message: 'Email kh√¥ng h·ª£p l·ªá' 
      });
    }

    const referrer = await User.findOne({ email: referralCode.toLowerCase() });
    if (!referrer) {
      return res.status(404).json({ 
        valid: false, 
        message: 'Email ng∆∞·ªùi gi·ªõi thi·ªáu kh√¥ng t·ªìn t·∫°i' 
      });
    }

    res.json({
      valid: true,
      referrerName: referrer.name,
      message: 'Email ng∆∞·ªùi gi·ªõi thi·ªáu h·ª£p l·ªá'
    });
  } catch (err) {
    console.error('Error checking referral code:', err);
    res.status(500).json({ 
      valid: false, 
      message: 'L·ªói server' 
    });
  }
});

// ƒêƒÉng nh·∫≠p
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // T√¨m user b·∫±ng email ho·∫∑c username
    const user = await User.findOne({
      $or: [
        { email: email },
        { username: email }
      ]
    });
    
    if (!user) return res.status(400).json({ message: 'Sai email/t√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u' });
    if (!user.isActive) return res.status(400).json({ message: 'T√†i kho·∫£n ƒë√£ b·ªã kh√≥a' });
    
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) return res.status(400).json({ message: 'Sai email/t√™n ƒëƒÉng nh·∫≠p ho·∫∑c m·∫≠t kh·∫©u' });
    
    const token = jwt.sign({ id: user._id, role: user.role }, process.env.JWT_SECRET, { expiresIn: '1d' });
    res.json({ 
      token, 
      user: { 
        id: user._id, 
        name: user.name, 
        email: user.email, 
        username: user.username,
        role: user.role 
      } 
    });
  } catch (err) {
    res.status(500).json({ message: 'L·ªói server' });
  }
});

// T·∫°o admin m·ªõi (route ·∫©n)
router.post('/create-admin', async (req, res) => {
  try {
    console.log('Create admin request received:', req.body);
    
    const { username, email, password, fullName, phone } = req.body;
    
    // Validation
    if (!username || !email || !password || !fullName) {
      return res.status(400).json({ message: 'Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc' });
    }
    
    // Ki·ªÉm tra email ƒë√£ t·ªìn t·∫°i
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'Email ƒë√£ t·ªìn t·∫°i' });
    }

    // Ki·ªÉm tra username ƒë√£ t·ªìn t·∫°i
    const existingUsername = await User.findOne({ username });
    if (existingUsername) {
      return res.status(400).json({ message: 'T√™n ƒëƒÉng nh·∫≠p ƒë√£ t·ªìn t·∫°i' });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // T·∫°o user admin m·ªõi
    const adminUser = new User({
      username,
      email,
      password: hashedPassword,
      name: fullName,
      phone,
      role: 'admin',
      isActive: true
    });

    await adminUser.save();
    console.log('Admin created successfully:', adminUser._id);

    res.status(201).json({ 
      message: 'T·∫°o admin th√†nh c√¥ng',
      user: {
        id: adminUser._id,
        username: adminUser.username,
        email: adminUser.email,
        name: adminUser.name,
        role: adminUser.role
      }
    });
  } catch (err) {
    console.error('Error creating admin:', err);
    res.status(500).json({ message: 'L·ªói server khi t·∫°o admin: ' + err.message });
  }
});

// Forgot password
router.post('/forgot-password', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ message: 'Vui l√≤ng nh·∫≠p email' });
    }
    
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(404).json({ message: 'Email kh√¥ng t·ªìn t·∫°i trong h·ªá th·ªëng' });
    }
    
    // T·∫°o reset token (c√≥ th·ªÉ s·ª≠ d·ª•ng JWT v·ªõi th·ªùi gian ng·∫Øn)
    const resetToken = jwt.sign(
      { id: user._id, type: 'password_reset' },
      process.env.JWT_SECRET,
      { expiresIn: '1h' }
    );
    
    // Trong th·ª±c t·∫ø, b·∫°n s·∫Ω g·ª≠i email v·ªõi link reset
    // Hi·ªán t·∫°i ch·ªâ tr·∫£ v·ªÅ token ƒë·ªÉ test
    res.json({
      message: 'Link reset password ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email c·ªßa b·∫°n',
      resetToken: resetToken // Ch·ªâ tr·∫£ v·ªÅ trong m√¥i tr∆∞·ªùng development
    });
  } catch (err) {
    console.error('Error in forgot password:', err);
    res.status(500).json({ message: 'L·ªói server' });
  }
});

// Reset password
router.post('/reset-password', async (req, res) => {
  try {
    const { token, newPassword } = req.body;
    
    if (!token || !newPassword) {
      return res.status(400).json({ message: 'Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc' });
    }
    
    // Verify token
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    if (decoded.type !== 'password_reset') {
      return res.status(400).json({ message: 'Token kh√¥ng h·ª£p l·ªá' });
    }
    
    const user = await User.findById(decoded.id);
    if (!user) {
      return res.status(404).json({ message: 'User kh√¥ng t·ªìn t·∫°i' });
    }
    
    // Hash new password
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    
    // Update password
    user.password = hashedPassword;
    await user.save();
    
    res.json({ message: 'ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng' });
  } catch (err) {
    console.error('Error in reset password:', err);
    if (err.name === 'JsonWebTokenError') {
      return res.status(400).json({ message: 'Token kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n' });
    }
    res.status(500).json({ message: 'L·ªói server' });
  }
});

// Logout (optional - for server-side token invalidation)
router.post('/logout', auth, (req, res) => {
  // Trong th·ª±c t·∫ø, b·∫°n c√≥ th·ªÉ l∆∞u token v√†o blacklist
  // Hi·ªán t·∫°i ch·ªâ tr·∫£ v·ªÅ th√¥ng b√°o th√†nh c√¥ng
  res.json({ message: 'ƒêƒÉng xu·∫•t th√†nh c√¥ng' });
});

// Refresh token
router.post('/refresh-token', auth, (req, res) => {
  try {
    // T·∫°o token m·ªõi v·ªõi th·ªùi gian d√†i h∆°n
    const newToken = jwt.sign(
      { id: req.user.id, role: req.user.role },
      process.env.JWT_SECRET,
      { expiresIn: '7d' }
    );
    
    res.json({ 
      token: newToken,
      message: 'Token ƒë√£ ƒë∆∞·ª£c l√†m m·ªõi'
    });
  } catch (err) {
    console.error('Error refreshing token:', err);
    res.status(500).json({ message: 'L·ªói server' });
  }
});

// Check if email exists
router.post('/check-email', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ message: 'Vui l√≤ng nh·∫≠p email' });
    }
    
    const user = await User.findOne({ email });
    res.json({ 
      exists: !!user,
      message: user ? 'Email ƒë√£ t·ªìn t·∫°i' : 'Email c√≥ th·ªÉ s·ª≠ d·ª•ng'
    });
  } catch (err) {
    console.error('Error checking email:', err);
    res.status(500).json({ message: 'L·ªói server' });
  }
});

// Check if username exists
router.post('/check-username', async (req, res) => {
  try {
    const { username } = req.body;
    
    if (!username) {
      return res.status(400).json({ message: 'Vui l√≤ng nh·∫≠p t√™n ƒëƒÉng nh·∫≠p' });
    }
    
    const user = await User.findOne({ username });
    res.json({ 
      exists: !!user,
      message: user ? 'T√™n ƒëƒÉng nh·∫≠p ƒë√£ t·ªìn t·∫°i' : 'T√™n ƒëƒÉng nh·∫≠p c√≥ th·ªÉ s·ª≠ d·ª•ng'
    });
  } catch (err) {
    console.error('Error checking username:', err);
    res.status(500).json({ message: 'L·ªói server' });
  }
});

// Test endpoint
router.get('/test', (req, res) => {
  res.json({ message: 'Auth route is working!' });
});

module.exports = router; 