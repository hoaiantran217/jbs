const User = require('../models/User');
const Transaction = require('../models/Transaction');
const InvestmentPackage = require('../models/InvestmentPackage');
const Post = require('../models/Post');
const Notification = require('../models/Notification');
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

// Admin: l·∫•y th·ªëng k√™ t·ªïng quan
exports.getDashboardStats = async (req, res) => {
  try {
    // USERS
    const now = new Date();
    const weekAgo = new Date(now);
    weekAgo.setDate(now.getDate() - 7);
    const [totalUsers, activeUsers, newThisWeek] = await Promise.all([
      User.countDocuments({ role: 'user' }),
      User.countDocuments({ role: 'user', isActive: true }),
      User.countDocuments({ role: 'user', createdAt: { $gte: weekAgo } })
    ]);

    // TRANSACTIONS
    const [
      totalTransactions,
      depositCount,
      withdrawCount,
      investmentCount,
      interestCount,
      pendingCount,
      approvedCount,
      rejectedCount,
      recentTransactions
    ] = await Promise.all([
      Transaction.countDocuments(),
      Transaction.countDocuments({ type: 'deposit' }),
      Transaction.countDocuments({ type: 'withdraw' }),
      Transaction.countDocuments({ type: 'investment' }),
      Transaction.countDocuments({ type: 'interest' }),
      Transaction.countDocuments({ status: 'pending' }),
      Transaction.countDocuments({ status: 'approved' }),
      Transaction.countDocuments({ status: 'rejected' }),
      Transaction.countDocuments({ createdAt: { $gte: weekAgo } })
    ]);

    // TRANSACTION AMOUNTS
    const [
      totalDeposits,
      totalWithdrawals,
      totalInterest,
      totalInvestments
    ] = await Promise.all([
      Transaction.aggregate([
        { $match: { type: 'deposit', status: 'approved' } },
        { $group: { _id: null, total: { $sum: "$amount" } } }
      ]),
      Transaction.aggregate([
        { $match: { type: 'withdraw', status: 'approved' } },
        { $group: { _id: null, total: { $sum: "$amount" } } }
      ]),
      Transaction.aggregate([
        { $match: { type: 'interest', status: 'approved' } },
        { $group: { _id: null, total: { $sum: "$amount" } } }
      ]),
      Transaction.aggregate([
        { $match: { type: 'investment', status: 'approved' } },
        { $group: { _id: null, total: { $sum: "$amount" } } }
      ])
    ]);

    // PACKAGES
    const [totalPackages, activePackages] = await Promise.all([
      InvestmentPackage.countDocuments(),
      InvestmentPackage.countDocuments({ isActive: true })
    ]);

    res.json({
      users: {
        total: totalUsers,
        active: activeUsers,
        newThisWeek: newThisWeek
      },
      transactions: {
        total: totalTransactions,
        byType: {
          deposit: depositCount,
          withdraw: withdrawCount,
          investment: investmentCount,
          interest: interestCount
        },
        pending: pendingCount,
        approved: approvedCount,
        rejected: rejectedCount,
        recent: {
          transactions: recentTransactions
        }
      },
      amounts: {
        totalDeposits: totalDeposits[0]?.total || 0,
        totalWithdrawals: totalWithdrawals[0]?.total || 0,
        totalInterest: totalInterest[0]?.total || 0,
        totalInvestments: totalInvestments[0]?.total || 0
      },
      packages: {
        total: totalPackages,
        active: activePackages
      }
    });
  } catch (err) {
    res.status(500).json({ message: 'L·ªói server' });
  }
};

// Admin: Reset to√†n b·ªô database (CH·ªà D√ôNG KHI C·∫¶N THI·∫æT!)
exports.resetDatabase = async (req, res) => {
  try {
    console.log('‚ö†Ô∏è  ADMIN ƒêANG RESET DATABASE!');
    
    // X√≥a t·∫•t c·∫£ collections
    const collections = await mongoose.connection.db.listCollections().toArray();
    
    for (const collection of collections) {
      console.log(`üóëÔ∏è  ƒêang x√≥a collection: ${collection.name}`);
      await mongoose.connection.db.dropCollection(collection.name);
    }

    // T·∫°o l·∫°i admin user m·∫∑c ƒë·ªãnh
    const hashedPassword = await bcrypt.hash('admin123', 10);
    const adminUser = new User({
      name: 'Admin',
      email: 'admin@zuna.com',
      password: hashedPassword,
      role: 'admin',
      balance: 0,
      isActive: true
    });
    await adminUser.save();

    res.json({ 
      message: '‚úÖ ƒê√£ reset to√†n b·ªô database th√†nh c√¥ng!',
      warning: '‚ö†Ô∏è  T·∫•t c·∫£ d·ªØ li·ªáu ƒë√£ b·ªã x√≥a vƒ©nh vi·ªÖn!'
    });
    
  } catch (error) {
    console.error('‚ùå L·ªói khi reset database:', error);
    res.status(500).json({ message: 'L·ªói khi reset database', error: error.message });
  }
};

// L·∫•y th·ªëng k√™ chi ti·∫øt theo th·ªùi gian
exports.getTimeBasedStats = async (req, res) => {
  try {
    const { period = '7days' } = req.query;
    let startDate = new Date();
    
    switch (period) {
      case '7days':
        startDate.setDate(startDate.getDate() - 7);
        break;
      case '30days':
        startDate.setDate(startDate.getDate() - 30);
        break;
      case '90days':
        startDate.setDate(startDate.getDate() - 90);
        break;
      default:
        startDate.setDate(startDate.getDate() - 7);
    }

    // Th·ªëng k√™ giao d·ªãch theo ng√†y
    const transactionStats = await Transaction.aggregate([
      {
        $match: {
          createdAt: { $gte: startDate }
        }
      },
      {
        $group: {
          _id: {
            date: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } },
            type: "$type"
          },
          count: { $sum: 1 },
          totalAmount: { $sum: "$amount" }
        }
      },
      {
        $sort: { "_id.date": 1 }
      }
    ]);

    // Th·ªëng k√™ ng∆∞·ªùi d√πng m·ªõi theo ng√†y
    const userStats = await User.aggregate([
      {
        $match: {
          createdAt: { $gte: startDate }
        }
      },
      {
        $group: {
          _id: {
            $dateToString: { format: "%Y-%m-%d", date: "$createdAt" }
          },
          count: { $sum: 1 }
        }
      },
      {
        $sort: { _id: 1 }
      }
    ]);

    res.json({
      period,
      startDate,
      transactionStats,
      userStats
    });
  } catch (err) {
    console.error('Time-based stats error:', err);
    res.status(500).json({ message: 'L·ªói server', error: err.message });
  }
}; 

// X√≥a to√†n b·ªô d·ªØ li·ªáu database (CH·ªà D√ÄNH CHO ADMIN)
exports.clearAllData = async (req, res) => {
  try {
    // Ki·ªÉm tra quy·ªÅn admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({ message: 'Ch·ªâ admin m·ªõi c√≥ quy·ªÅn th·ª±c hi·ªán h√†nh ƒë·ªông n√†y' });
    }

    const { confirmation, password } = req.body;
    
    // Y√™u c·∫ßu x√°c nh·∫≠n ƒë·∫∑c bi·ªát
    if (confirmation !== 'DELETE_ALL_DATA_CONFIRM') {
      return res.status(400).json({ 
        message: 'X√°c nh·∫≠n kh√¥ng ƒë√∫ng. Vui l√≤ng nh·∫≠p: DELETE_ALL_DATA_CONFIRM' 
      });
    }

    // Ki·ªÉm tra password admin
    const admin = await User.findById(req.user.id);
    const isPasswordValid = await bcrypt.compare(password, admin.password);
    if (!isPasswordValid) {
      return res.status(400).json({ message: 'M·∫≠t kh·∫©u admin kh√¥ng ƒë√∫ng' });
    }

    console.log('üö® ADMIN CLEARING ALL DATABASE DATA...');
    console.log('Admin:', req.user.email);
    console.log('Time:', new Date().toISOString());

    // X√≥a t·∫•t c·∫£ collections
    const collections = [
      'users',
      'transactions', 
      'investments',
      'investmentpackages',
      'posts',
      'notifications',
      'reviews',
      'bankinfos',
      'attendances',
      'teammembers',
      'investmentdata',
      'identityverifications',
      'withdrawalnotifications',
      'transactionnotifications',
      'securityconfigs',
      'referraltransactions'
    ];

    let deletedCount = 0;
    for (const collectionName of collections) {
      try {
        const collection = mongoose.connection.collection(collectionName);
        const result = await collection.deleteMany({});
        deletedCount += result.deletedCount;
        console.log(`‚úÖ Deleted ${result.deletedCount} documents from ${collectionName}`);
      } catch (err) {
        console.log(`‚ö†Ô∏è Error deleting ${collectionName}:`, err.message);
      }
    }

    // T·∫°o admin m·∫∑c ƒë·ªãnh
    const defaultAdmin = new User({
      username: 'admin',
      email: 'admin@jbs.com',
      password: await bcrypt.hash('admin123', 10),
      name: 'Administrator',
      role: 'admin',
      isActive: true,
      balance: 0,
      referralCode: 'admin@jbs.com'
    });
    await defaultAdmin.save();

    console.log('‚úÖ Created default admin account');
    console.log('üìä Total documents deleted:', deletedCount);

    res.json({ 
      message: 'ƒê√£ x√≥a to√†n b·ªô d·ªØ li·ªáu th√†nh c√¥ng',
      deletedCount,
      defaultAdmin: {
        email: 'admin@jbs.com',
        password: 'admin123'
      }
    });

  } catch (err) {
    console.error('‚ùå Error clearing database:', err);
    res.status(500).json({ message: 'L·ªói khi x√≥a d·ªØ li·ªáu' });
  }
}; 

// ƒêi·ªÅu khi·ªÉn console output
exports.controlConsole = async (req, res) => {
  try {
    const { action, levels } = req.body;
    const consoleManager = require('../utils/consoleManager');

    switch (action) {
      case 'disableAll':
        consoleManager.disableAll();
        res.json({ message: 'ƒê√£ ch·∫∑n t·∫•t c·∫£ console output' });
        break;
      
      case 'disableLevels':
        if (levels && Array.isArray(levels)) {
          consoleManager.disableLevels(levels);
          res.json({ message: `ƒê√£ ch·∫∑n console levels: ${levels.join(', ')}` });
        } else {
          res.status(400).json({ message: 'Thi·∫øu tham s·ªë levels' });
        }
        break;
      
      case 'restoreAll':
        consoleManager.restoreAll();
        res.json({ message: 'ƒê√£ kh√¥i ph·ª•c t·∫•t c·∫£ console output' });
        break;
      
      case 'getStatus':
        const status = consoleManager.getStatus();
        res.json({ 
          message: 'Tr·∫°ng th√°i console output',
          status 
        });
        break;
      
      default:
        res.status(400).json({ message: 'H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá' });
    }
  } catch (err) {
    console.error('‚ùå Error controlling console:', err);
    res.status(500).json({ message: 'L·ªói khi ƒëi·ªÅu khi·ªÉn console' });
  }
}; 